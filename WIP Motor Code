#include <ros/ros.h>
#include <std_msgs/Float64.h>
#include <math.h>

#define TOLERANCE 0.01  // Tolerance for reaching the target position
#define MOTOR_SPEED 1.0 // Default motor speed in rad/s

// Global variables for encoder values
double sort_current_pos = 0.0;
double trough_current_pos = 0.0;

// Callback for Sort motor encoder
void SortEncoderCallback(const std_msgs::Float64::ConstPtr& msg) {
    sort_current_pos = msg->data;
}

// Callback for Trough motor encoder
void TroughEncoderCallback(const std_msgs::Float64::ConstPtr& msg) {
    trough_current_pos = msg->data;
}

// Function to move Sort motor to π/5 and back to 0
void moveSortToPiOver5(ros::Publisher& sort_pub) {
    std_msgs::Float64 command;
    ros::Rate rate(100);  // 100 Hz loop rate
    double target = M_PI / 5;

    // Move to π/5
    while (fabs(sort_current_pos - target) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((sort_current_pos < target) ? 1 : -1);
        sort_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    sort_pub.publish(command);

    // Return to 0
    while (fabs(sort_current_pos) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((sort_current_pos > 0) ? -1 : 1);
        sort_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    sort_pub.publish(command);
}

// Function to move Trough motor to 2π/3 and back to 0
void moveTroughTo2PiOver3(ros::Publisher& trough_pub) {
    std_msgs::Float64 command;
    ros::Rate rate(100);  // 100 Hz loop rate
    double target = 2 * M_PI / 3;

    // Move to 2π/3
    while (fabs(trough_current_pos - target) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((trough_current_pos < target) ? 1 : -1);
        trough_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    trough_pub.publish(command);

    // Return to 0
    while (fabs(trough_current_pos) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((trough_current_pos > 0) ? -1 : 1);
        trough_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    trough_pub.publish(command);
}

// Function to move Trough motor to -2π/3 and back to 0
void moveTroughToMinus2PiOver3(ros::Publisher& trough_pub) {
    std_msgs::Float64 command;
    ros::Rate rate(100);  // 100 Hz loop rate
    double target = -2 * M_PI / 3;

    // Move to -2π/3
    while (fabs(trough_current_pos - target) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((trough_current_pos < target) ? 1 : -1);
        trough_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    trough_pub.publish(command);

    // Return to 0
    while (fabs(trough_current_pos) > TOLERANCE) {
        command.data = MOTOR_SPEED * ((trough_current_pos > 0) ? -1 : 1);
        trough_pub.publish(command);
        ros::spinOnce();
        rate.sleep();
    }

    // Stop motor
    command.data = 0.0;
    trough_pub.publish(command);
}

int main(int argc, char** argv) {
    ros::init(argc, argv, "motor_controller");
    ros::NodeHandle nh;

    // Publishers for motor angular velocity
    ros::Publisher sort_pub = nh.advertise<std_msgs::Float64>"/6_ang_vel", 10);
    ros::Publisher trough_pub = nh.advertise<std_msgs::Float64>"/5_ang_vel", 10);

    // Subscribers for encoders
    ros::Subscriber sort_enc_sub = nh.subscribe("/6_enc", 10, SortEncoderCallback);
    ros::Subscriber trough_enc_sub = nh.subscribe("/5_enc", 10, TroughEncoderCallback);

    // Example usage of the functions
    moveSortToPiOver5(sort_pub);
    moveTroughTo2PiOver3(trough_pub);
    moveTroughToMinus2PiOver3(trough_pub);

    return 0;
}
